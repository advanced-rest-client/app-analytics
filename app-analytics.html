<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../app-pouchdb/app-pouchdb-conflict-resolution.html">
<link rel="import" href="../app-pouchdb/app-pouchdb-index.html">
<link rel="import" href="../app-pouchdb/app-pouchdb-query.html">
<link rel="import" href="../app-pouchdb/app-pouchdb-document.html">
<link rel="import" href="../uuid-generator/uuid-generator.html">
<link rel="import" href="../connectivity-state/connectivity-state.html">
<link rel="import" href="app-analytics-behavior.html">
<!--
`<app-analytics>` An element that support Google Analytics analysis

### Example
```
<app-analytics tracking-id="UA-XXXXXXX-Y"></app-analytics>
```

@group Logic Elements
@element app-analytics
@demo demo/index.html

-->
<dom-module id="app-analytics">
  <template>
    <style>
     :host {
      display: none;
    }
    </style>
    <app-pouchdb-conflict-resolution strategy="lastWriteWins"></app-pouchdb-conflict-resolution>
    <app-pouchdb-index db-name="[[_analyticsStore]]" fields="[[_storeIndexFields]]"></app-pouchdb-index>
    <app-pouchdb-query id="q" db-name="[[_analyticsStore]]" id="query" limit="20" selector="sent $eq false" sort="[[_storeIndexFields]]" fields="[[_storeQueryFields]]" data="{{_offlineResult}}"></app-pouchdb-query>
    <app-pouchdb-document db-name="[[_analyticsStore]]" doc-id="metadata" data="{{_metaData}}"></app-pouchdb-document>
    <uuid-generator id="uuid"></uuid-generator>
    <connectivity-state online="{{isOnline}}"></connectivity-state>
  </template>
  <script>
  Polymer({
    is: 'app-analytics',
    behaviors: [ArcBehaviors.AppAnalyticsBehavior],
    /**
     * An event fired when the Google Analytics configuration is set and ready to rock.
     * It doesn't matter if tracking is permitted. The tracking object will be ready
     * to enable tracking on user demand.
     *
     * @event app-analytics-ready
     * @param {String} trackingId A tracking ID related to this configuration.
     */
    /**
     * Firwed when Library `permitted` state changed.
     *
     * @event app-analytics-permitted-changed
     * @param {Boolean} permitted Current state.
     */
    properties: {
      // Name of the datastore of the GA offline data.
      _analyticsStore: {
        type: String,
        value: 'analytics-offline-store'
      },
      // Oflline storage indexes
      _storeIndexFields: {
        type: Array,
        value: function() {
          return ['sent'];
        }
      },
      // Offline storage query fields.
      _storeQueryFields: {
        type: Array,
        value: function() {
          return ['_id', 'sent'];
        }
      },
      // List of commands that should be executed.
      _offlineResult: Array,
      /**
       * Internal metadata that keeps information about:
       * - cid - client id used to recognize the user accross the sessions
       * - enabled - information is this instance of analytics is enabled.
       */
      _metaData: Object,

      customDataQueue: {
        type: Array,
        value: function() {
          return [];
        }
      },

      queue: {
        type: Array,
        value: function() {
          return [];
        }
      },
      // If true the app probably is online. See `<connectivity-state>`.
      isOnline: Boolean,
      /**
       * If true tracking is active.
       */
      enabled: {
        type: Boolean,
        notify: true
      }
    },

    observers: [
      '_metaDataChanged(_metaData.*)',
      '__uploadOffline(inited, isOnline, _offlineResult.*)',
      '__checkOfflineUpload(isOnline)'
    ],

    listeners: {
      'app-analytics-custom-changed': '_customPropertyChanged',
      'app-analytics-custom-removed': '_customPropertyRemoved'
    },

    attached: function() {
      this._eventTarget = Polymer.dom(this).host || document;
      this.listen(this._eventTarget, 'app-analytics-permitted', '_permittedHandler');
      this.listen(this._eventTarget, 'send-analytics', '_sendHandler');
    },

    detached: function() {
      this.unlisten(this._eventTarget, 'app-analytics-permitted', '_permittedHandler');
      this.unlisten(this._eventTarget, 'send-analytics', '_sendHandler');
    },

    /**
     * Sets metadata for the app and manages defaults.
     * This function initialize library basic configuraion if it hasen't
     * been already set.
     * Finally it will set corresponding properties on the element.
     */
    _metaDataChanged: function(change) {
      var meta = this._metaData;
      if (!meta) {
        return;
      }
      if (meta._id && meta._rev) {
        // set defaults
        if (typeof meta.enabled === 'undefined') {
          this.async(function() {
            this.set('_metaData.enabled', true);
          });
        }
        if (typeof meta.disableTracking === 'undefined') {
          this.async(function() {
            this.set('_metaData.disableTracking', false);
          });
        }
        if (!meta.cid) {
          this.async(function() {
            let uuid = this.clientId;
            if (!uuid) {
              uuid = this.$.uuid.generate();
            }
            this.set('_metaData.cid', uuid);
          });
        }
      }

      if (meta.cid !== this.clientId) {
        this.set('clientId', meta.cid);
      }
      if (meta.enabled !== this.enabled) {
        this.set('enabled', Boolean(meta.enabled));
      }
      if (meta.disableTracking !== this.disableTracking) {
        this.set('disableTracking', Boolean(meta.disableTracking));
      }
    },

    // An event handler for `send-analytics`
    _sendHandler: function(e) {
      if (!e.detail) {
        return;
      }
      if (!this.enabled) {
        e.detail.sent = false;
        e.detail.message = 'Tracking is disabled.';
        return;
      }

      if (!this.inited) {
        this.queue.push(e);
        return;
      }

      var d = e.detail;
      switch (d.type) {
        case 'screenview':
          this.sendScreen(d.name);
          e.detail.sent = true;
          break;
        case 'event':
          this.sendEvent(d.category, d.action, d.label, d.value);
          e.detail.sent = true;
          break;
        case 'exception':
          this.sendException(d.description, d.fatal);
          e.detail.sent = true;
          break;
        case 'social':
          this.sendSocial(d.network, d.action, d.target);
          e.detail.sent = true;
          break;
        case 'timing':
          try {
            this.sendTimings(d.category, d.variable, d.value, d.label);
            e.detail.sent = true;
          } catch (e) {
            e.detail.sent = false;
            e.detail.message = e.message;
          }
          break;
        default:
          e.detail.sent = false;
          e.detail.message = 'Unknown type [' + d.type + ']';
          break;
      }
    },

    // Enable or disable GA.
    _permittedHandler: function(e) {
      if (typeof e.detail.permitted === 'undefined') {
        e.detail.error = true;
        e.detail.message = 'Set `permitted` detail property first.';
        return;
      }
      var state = Boolean(e.detail.permitted);
      this.set('enabled', state);
    },

    _processQueue: function() {
      var len = this.queue.length;
      if (len) {
        for (let i = 0; i < len; i++) {
          this._sendHandler(this.queue[i]);
        }
      }
      this.queue = [];
      len = this.customDataQueue.length;
      if (len) {
        for (let i = 0; i < len; i++) {
          this._customPropertyChanged(this.customDataQueue[i]);
        }
      }
      this.customDataQueue = [];
    },

    // Handler for app-analytics-custom-changed event. Registers a new custom property.
    _customPropertyChanged: function(e) {
      if (!this.tracker) {
        this.customDataQueue.push(e);
        return;
      }
      var d = e.detail;
      if (d.type === 'dimension') {
        this.addCustomDimension(d.index, d.value);
      } else if (d.type === 'metric') {
        this.addCustomMetric(d.index, d.value);
      } else {
        return;
      }
    },
    // Handler for app-analytics-custom-removed event. Unregisters a custom property.
    _customPropertyRemoved: function(e) {
      if (this.removedCustomData.indexOf(e.detail.name) !== -1) {
        return;
      }
      this.removedCustomData.push(e.detail.name);
    },

    _storeOffline: function(data) {
      this.$.q.db.post({
        time: Date.now(),
        body: data,
        sent: false
      });
    },

    /**
     * The function checks if the app is online, then checks is has some data
     * to send to GA server and finally sends them.
     */
    __checkOfflineUpload: function(isOnline) {
      if (!isOnline) {
        return;
      }
      this.$.q.refresh();
    },

    /**
     * Uploads Google Analytics offline data to GA server.
     * Offline store stores full GA command ready to sent to GA server.
     * When the app initializes or network state change to online it will
     * check if any data exists in the send queue (in the database) and if
     * they are it will upload data to the server.
     *
     * Note, that according to GA documentation a hist taht are more than 4
     * hrs old may not be processed.
     *
     * Takes 20 first elements,
     * Upload to the GA server,
     * Update their status,
     * query db (call refresh)
     * end.
     */
    __uploadOffline: function(inited, isOnline) {
      if (!inited || !isOnline) {
        return;
      }

      if (!this._offlineResult || !this._offlineResult.length) {
        return;
      }

      let promises = this._offlineResult.map((item) => {
        return this.$.q.db.get(item._id);
      });
      Promise.all(promises).then((list) => {
        this.sendBulk(list);
      })
      .then((list) => {
        console.log('__uploadOffline');
        // list.forEach((item) => item.sent = true);
        // return this.$.q.db.bulkDocs(list);
      })
      .catch((e) => console.error(e));
    }
  });
  </script>
</dom-module>
