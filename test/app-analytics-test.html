<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../iron-test-helpers/test-helpers.js"></script>
    <link rel="import" href="../app-analytics.html">
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <app-analytics tracking-id="UA-71458341-4" app-name="app-analytics-test" app-version="dev" data-source="app-analytics element"></app-analytics>
      </template>
    </test-fixture>

    <test-fixture id="DebugEndpoint">
      <template>
        <app-analytics tracking-id="UA-71458341-4" app-name="app analytics test" app-version="dev" data-source="app-analytics element" debug-endpoint></app-analytics>
      </template>
    </test-fixture>
    <script>
    const disabledKey = 'apic.ga.disabled';
    const cidKey = 'apic.ga.cid';
    suite('_restoreConfiguration()', () => {
      let element;
      setup(() => {
        localStorage.setItem(disabledKey, 'false');
        element = fixture('Basic');
      });

      test('Initialize clientId when element is created', () => {
        assert.typeOf(element.clientId, 'string');
      });

      test('Does nothing when already initialized', () => {
        const spy = sinon.spy(element, 'set');
        element._restoreConfiguration();
        assert.isFalse(spy.called);
      });

      test('Will not set clientId when disabled', () => {
        localStorage.setItem(disabledKey, 'true');
        element.clientId = undefined;
        element._restoreConfiguration();
        assert.isUndefined(element.clientId);
      });

      test('Generates new key', () => {
        const old = localStorage.getItem(cidKey);
        localStorage.removeItem(cidKey);
        element.clientId = undefined;
        element._restoreConfiguration();
        assert.typeOf(element.clientId, 'string');
        assert.notEqual(element.clientId, old);
      });
    });

    suite('_cidChanged()', () => {
      let element;
      setup(() => {
        localStorage.setItem(disabledKey, 'false');
        element = fixture('Basic');
      });

      test('Stores new clientId in local storage', () => {
        element.clientId = 'test-cid';
        const result = localStorage.getItem(cidKey);
        assert.equal(result, element.clientId);
      });

      test('Ignores storing when value did not changed', () => {
        element.clientId = 'test-cid';
        element._cidChanged('test-cid');
        // this is for coverage, sinon does not allows localState.setItem to
        // be wrapped.
      });

      test('Calls _configureBaseParams()', () => {
        const spy = sinon.spy(element, '_configureBaseParams');
        element._cidChanged('test-cid');
        assert.isTrue(spy.called);
      });
    });

    suite('_disabledChanged()', () => {
      let element;
      setup(() => {
        localStorage.setItem(disabledKey, 'true');
        element = fixture('Basic');
      });

      test('Changes state in local sotrage', () => {
        element._disabledChanged(false);
        const value = localStorage.getItem(disabledKey);
        assert.equal(value, 'false');
      });

      test('Calls _restoreConfiguration() when not disabled', () => {
        const spy = sinon.spy(element, '_restoreConfiguration');
        element._disabledChanged(false);
        assert.isTrue(spy.called);
      });

      test('Calls _configureBaseParams() when not disabled', () => {
        const spy = sinon.spy(element, '_configureBaseParams');
        element._disabledChanged(false);
        assert.isTrue(spy.called);
      });

      test('Won\'t call _restoreConfiguration() when disabled', () => {
        const spy = sinon.spy(element, '_restoreConfiguration');
        element._disabledChanged(true);
        assert.isFalse(spy.called);
      });

      test('Won\'t call _configureBaseParams() when disabled', () => {
        const spy = sinon.spy(element, '_configureBaseParams');
        element._disabledChanged(true);
        assert.isFalse(spy.called);
      });
    });

    suite('addCustomDimension()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Throws when index is not a number', () => {
        assert.throws(() => {
          element.addCustomDimension('test');
        }, 'Index is not a number.');
      });

      test('Throws when index below the range', () => {
        assert.throws(() => {
          element.addCustomDimension(0);
        }, 'Index out of bounds');
      });

      test('Throws when index above the range', () => {
        assert.throws(() => {
          element.addCustomDimension(201);
        }, 'Index out of bounds');
      });

      test('Adds new custom dimension', () => {
        element.addCustomDimension(1, 'test');
        assert.lengthOf(element.customDimensions, 1);
      });

      test('Creates customDimensions', () => {
        element.addCustomDimension(1, 'test');
        assert.lengthOf(element.customDimensions, 1);
      });

      test('Adds new item to customDimensions', () => {
        element._setCustomDimensions([{index: 2, value: 'x'}]);
        element.addCustomDimension(1, 'test');
        assert.lengthOf(element.customDimensions, 2);
      });

      test('Updates custom dimension when value is different', () => {
        element._setCustomDimensions([{index: 1, value: 'other'}]);
        element.addCustomDimension(1, 'test');
        assert.equal(element.customDimensions[0].value, 'test');
      });

      test('Will not update custom dimension when value is the same', () => {
        element._setCustomDimensions([{index: 1, value: 'other'}]);
        const spy = sinon.spy(element, 'set');
        element.addCustomDimension(1, 'other');
        assert.isFalse(spy.called);
      });

      test('Calls _configureBaseParams()', () => {
        const spy = sinon.spy(element, '_configureBaseParams');
        element.addCustomDimension(1, 'test');
        assert.isTrue(spy.called);
      });
    });

    suite('removeCustomDimension()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
        element._setCustomDimensions([{index: 1, value: 'one'}, {index: 2, value: 'other'}]);
      });

      test('Removes CD by its index', () => {
        element.removeCustomDimension(1);
        assert.lengthOf(element.customDimensions, 1);
        assert.equal(element.customDimensions[0].value, 'other');
      });

      test('Calls _configureBaseParams()', () => {
        const spy = sinon.spy(element, '_configureBaseParams');
        element.removeCustomDimension(2);
        assert.isTrue(spy.called);
      });

      test('Does nothing when index not found', () => {
        const spy = sinon.spy(element, '_configureBaseParams');
        element.removeCustomDimension(3);
        assert.isFalse(spy.called);
      });
    });

    suite('addCustomMetric()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Throws when index is not a number', () => {
        assert.throws(() => {
          element.addCustomMetric('test');
        }, 'Index is not a number.');
      });

      test('Throws when index below the range', () => {
        assert.throws(() => {
          element.addCustomMetric(0);
        }, 'Index out of bounds');
      });

      test('Throws when index above the range', () => {
        assert.throws(() => {
          element.addCustomMetric(201);
        }, 'Index out of bounds');
      });

      test('Adds new custom metric', () => {
        element.addCustomMetric(1, 'test');
        assert.lengthOf(element.customMetrics, 1);
      });

      test('Creates customMetrics array', () => {
        element.addCustomMetric(1, 'test');
        assert.lengthOf(element.customMetrics, 1);
      });

      test('Adds new item to customMetrics', () => {
        element._setCustomMetrics([{index: 2, value: 'x'}]);
        element.addCustomMetric(1, 'test');
        assert.lengthOf(element.customMetrics, 2);
      });

      test('Updates custom dimension when value is different', () => {
        element._setCustomMetrics([{index: 1, value: 'other'}]);
        element.addCustomMetric(1, 'test');
        assert.equal(element.customMetrics[0].value, 'test');
      });

      test('Will not update custom dimension when value is the same', () => {
        element._setCustomMetrics([{index: 1, value: 'other'}]);
        const spy = sinon.spy(element, 'set');
        element.addCustomMetric(1, 'other');
        assert.isFalse(spy.called);
      });

      test('Calls _configureBaseParams()', () => {
        const spy = sinon.spy(element, '_configureBaseParams');
        element.addCustomMetric(1, 'test');
        assert.isTrue(spy.called);
      });
    });

    suite('removeCustomMetric()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
        element._setCustomMetrics([{index: 1, value: 'one'}, {index: 2, value: 'other'}]);
      });

      test('Removes CM by its index', () => {
        element.removeCustomMetric(1);
        assert.lengthOf(element.customMetrics, 1);
        assert.equal(element.customMetrics[0].value, 'other');
      });

      test('Calls _configureBaseParams()', () => {
        const spy = sinon.spy(element, '_configureBaseParams');
        element.removeCustomMetric(2);
        assert.isTrue(spy.called);
      });

      test('Does nothing when index not found', () => {
        const spy = sinon.spy(element, '_configureBaseParams');
        element.removeCustomMetric(3);
        assert.isFalse(spy.called);
      });
    });

    suite('sendScreen()', () => {
      let element;
      setup(() => {
        localStorage.setItem(disabledKey, 'true');
        element = fixture('DebugEndpoint');
      });

      test('Returns a promise', () => {
        const result = element.sendScreen('Test');
        assert.typeOf(result.then, 'function');
        return result;
      });

      test('Calls appendCustomData()', () => {
        const spy = sinon.spy(element, 'appendCustomData');
        return element.sendScreen('Test')
        .then(() => {
          assert.isTrue(spy.called);
        });
      });

      test('Calls sendHit()', () => {
        const spy = sinon.spy(element, 'sendHit');
        return element.sendScreen('Test')
        .then(() => {
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'screenview');
          assert.deepEqual(spy.args[0][1], {
            cd: 'Test',
            t: 'screenview'
          });
        });
      });
    });

    suite('sendEvent()', () => {
      let element;
      const category = 'test-cat';
      const action = 'test-act';
      const label = 'test-label';
      const value = 'test-value';

      setup(() => {
        localStorage.setItem(disabledKey, 'true');
        element = fixture('DebugEndpoint');
      });

      test('Throws when category is missing', () => {
        assert.throws(() => {
          element.sendEvent(undefined, action, label, value);
        });
      });

      test('Throws when action is missing', () => {
        assert.throws(() => {
          element.sendEvent(category, undefined, label, value);
        });
      });

      test('Returns a promise', () => {
        const result = element.sendEvent(category, action, label, value);
        assert.typeOf(result.then, 'function');
        return result;
      });

      test('Calls appendCustomData()', () => {
        const spy = sinon.spy(element, 'appendCustomData');
        return element.sendEvent(category, action, label, value)
        .then(() => {
          assert.isTrue(spy.called);
        });
      });

      test('Calls sendHit()', () => {
        const spy = sinon.spy(element, 'sendHit');
        return element.sendEvent(category, action, label, value)
        .then(() => {
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'event');
          assert.deepEqual(spy.args[0][1], {
            ec: category,
            ea: action,
            el: label,
            ev: value,
            t: 'event'
          });
        });
      });

      test('Label is optional', () => {
        const spy = sinon.spy(element, 'sendHit');
        return element.sendEvent(category, action, undefined, value)
        .then(() => {
          assert.deepEqual(spy.args[0][1], {
            ec: category,
            ea: action,
            ev: value,
            t: 'event'
          });
        });
      });

      test('Value is optional', () => {
        const spy = sinon.spy(element, 'sendHit');
        return element.sendEvent(category, action, undefined, undefined)
        .then(() => {
          assert.deepEqual(spy.args[0][1], {
            ec: category,
            ea: action,
            t: 'event'
          });
        });
      });
    });

    suite('sendException()', () => {
      let element;
      const description = 'test-desc';
      const fatal = 'fatal-value';

      setup(() => {
        localStorage.setItem(disabledKey, 'true');
        element = fixture('DebugEndpoint');
      });

      test('Returns a promise', () => {
        const result = element.sendException(description, fatal);
        assert.typeOf(result.then, 'function');
        return result;
      });

      test('Calls appendCustomData()', () => {
        const spy = sinon.spy(element, 'appendCustomData');
        return element.sendException(description, fatal)
        .then(() => {
          assert.isTrue(spy.called);
        });
      });

      test('Calls sendHit()', () => {
        const spy = sinon.spy(element, 'sendHit');
        return element.sendException(description, fatal)
        .then(() => {
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'exception');
          assert.deepEqual(spy.args[0][1], {
            exd: description,
            exf: '1',
            t: 'exception'
          });
        });
      });

      test('Respects "fatal" value', () => {
        const spy = sinon.spy(element, 'sendHit');
        return element.sendException(description, false)
        .then(() => {
          assert.deepEqual(spy.args[0][1], {
            exd: description,
            exf: '0',
            t: 'exception'
          });
        });
      });
    });

    suite('sendSocial()', () => {
      let element;
      const network = 'network-value';
      const action = 'action-value';
      const target = 'target-value';

      setup(() => {
        localStorage.setItem(disabledKey, 'true');
        element = fixture('DebugEndpoint');
      });

      test('Returns a promise', () => {
        const result = element.sendSocial(network, action, target);
        assert.typeOf(result.then, 'function');
        return result;
      });

      test('Calls appendCustomData()', () => {
        const spy = sinon.spy(element, 'appendCustomData');
        return element.sendSocial(network, action, target)
        .then(() => {
          assert.isTrue(spy.called);
        });
      });

      test('Calls sendHit()', () => {
        const spy = sinon.spy(element, 'sendHit');
        return element.sendSocial(network, action, target)
        .then(() => {
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'social');
          assert.deepEqual(spy.args[0][1], {
            sn: network,
            sa: action,
            st: target,
            t: 'social'
          });
        });
      });

      test('Throws when no network property', () => {
        assert.throws(() => {
          element.sendSocial(undefined, action, target);
        });
      });

      test('Throws when no action property', () => {
        assert.throws(() => {
          element.sendSocial(network, undefined, target);
        });
      });

      test('Throws when no target property', () => {
        assert.throws(() => {
          element.sendSocial(network, action, undefined);
        });
      });
    });

    suite('sendTimings()', () => {
      let element;
      const category = 'category-value';
      const variable = 'variable-value';
      const time = 'time-value';
      const label = 'label-value';

      setup(() => {
        localStorage.setItem(disabledKey, 'true');
        element = fixture('DebugEndpoint');
      });

      test('Returns a promise', () => {
        const result = element.sendTimings(category, variable, time, label);
        assert.typeOf(result.then, 'function');
        return result;
      });

      test('Calls appendCustomData()', () => {
        const spy = sinon.spy(element, 'appendCustomData');
        return element.sendTimings(category, variable, time, label)
        .then(() => {
          assert.isTrue(spy.called);
        });
      });

      test('Calls sendHit()', () => {
        const spy = sinon.spy(element, 'sendHit');
        return element.sendTimings(category, variable, time, label)
        .then(() => {
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'timing');
          assert.deepEqual(spy.args[0][1], {
            utc: category,
            utv: variable,
            utt: time,
            utl: label,
            t: 'timing'
          });
        });
      });

      test('Label is optional', () => {
        const spy = sinon.spy(element, 'sendHit');
        return element.sendTimings(category, variable, time)
        .then(() => {
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0], 'timing');
          assert.deepEqual(spy.args[0][1], {
            utc: category,
            utv: variable,
            utt: time,
            t: 'timing'
          });
        });
      });

      test('Throws when no category property', () => {
        assert.throws(() => {
          element.sendSocial(undefined, variable, time);
        });
      });

      test('Throws when no variable property', () => {
        assert.throws(() => {
          element.sendSocial(category, undefined, time);
        });
      });

      test('Throws when no time property', () => {
        assert.throws(() => {
          element.sendSocial(category, variable, undefined);
        });
      });
    });

    suite('appendCustomData()', () => {
      let element;

      setup(() => {
        element = fixture('DebugEndpoint');
      });

      test('Does nothing when no options', () => {
        const result = {};
        element.appendCustomData(result);
        assert.lengthOf(Object.keys(result), 0);
      });

      test('Adds custom dimensions', () => {
        const result = {};
        element.appendCustomData(result, {
          customDimensions: [{
            index: 1,
            value: 'test'
          }]
        });
        assert.equal(result.cd1, 'test');
      });

      test('Adds custom metrics', () => {
        const result = {};
        element.appendCustomData(result, {
          customMetrics: [{
            index: 1,
            value: 'test'
          }]
        });
        assert.equal(result.cm1, 'test');
      });
    });

    suite('sendHit()', () => {
      let element;

      setup(() => {
        localStorage.setItem(disabledKey, 'true');
        element = fixture('DebugEndpoint');
      });

      test('Throws when unknown type', () => {
        assert.throws(() => {
          element.sendHit('other', {});
        }, 'Unknown hit type.');
      });

      test('Sets type on the parmaeters', () => {
        const params = {};
        element.debug = true;
        element.sendHit('screenview', params);
        assert.equal(params.t, 'screenview');
      });

      test('Calls _processParams()', () => {
        const params = {};
        const spy = sinon.spy(element, '_processParams');
        element.sendHit('screenview', params);
        assert.isTrue(spy.called);
        assert.isTrue(spy.args[0][0] === params);
      });

      test('Calls _createBody()', () => {
        const params = {};
        const spy = sinon.spy(element, '_createBody');
        element.sendHit('screenview', params);
        assert.isTrue(spy.called, 'Function is called');
        assert.typeOf(spy.args[0][0], 'object', 'Sets parameters');
      });

      test('Calls _transport()', () => {
        const params = {};
        const spy = sinon.spy(element, '_transport');
        element.sendHit('screenview', params);
        assert.isTrue(spy.called);
        assert.typeOf(spy.args[0][0], 'string');
      });
    });

    suite('_processParams()', () => {
      let element;
      let opts;
      setup(() => {
        element = fixture('DebugEndpoint');
        opts = {a: 'test value', other: 'value'};
      });

      test('Calls encodeQueryString() for each parameter', () => {
        const spy = sinon.spy(element, 'encodeQueryString');
        element._processParams(opts);
        assert.equal(spy.callCount, 2);
      });

      test('Encodes values', () => {
        element._processParams(opts);
        assert.equal(opts.a, 'test+value');
      });
    });

    suite('_createBody()', () => {
      let element;
      let opts;
      setup(() => {
        element = fixture('DebugEndpoint');
        opts = {a: 'test value', other: 'value'};
      });

      test('Creates body value for each parameter', () => {
        const result = element._createBody(opts);
        assert.equal(result, 'a=test value&other=value');
      });
    });

    suite('_configureBaseParams()', () => {
      let element;

      setup(() => {
        localStorage.setItem(disabledKey, 'false');
        element = fixture('DebugEndpoint');
      });

      test('Sets baseParams object', () => {
        element._configureBaseParams();
        assert.typeOf(element.baseParams, 'object');
      });

      test('Sets all default properties', () => {
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.v, '1');
        assert.equal(p.tid, 'UA-71458341-4');
        assert.equal(p.cid, element.clientId);
        assert.typeOf(p.ul, 'string');
        assert.typeOf(p.sr, 'string');
        assert.typeOf(p.sd, 'string');
      });

      test('Sets vp property', () => {
        element._configureBaseParams();
        const p = element.baseParams;
        assert.typeOf(p.vp, 'string');
      });

      test('Sets uid property', () => {
        element.userId = 'test-uid';
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.uid, element.userId);
      });

      test('Sets aip property', () => {
        element.anonymizeIp = true;
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.aip, '1');
      });

      test('Sets ds property', () => {
        element.dataSource = 'https://domain.com';
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.ds, 'https%3A%2F%2Fdomain.com');
      });

      test('Sets dr property', () => {
        element.referrer = 'https://domain.com/path';
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.dr, 'https%3A%2F%2Fdomain.com%2Fpath');
      });

      test('Sets cn property', () => {
        element.campaignName = 'My name';
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.cn, 'My+name');
      });

      test('Sets cs property', () => {
        element.campaignSource = 'My source';
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.cs, 'My+source');
      });

      test('Sets cm property', () => {
        element.campaignMedium = 'My medium';
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.cm, 'My+medium');
      });

      test('Sets av property', () => {
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.av, 'dev');
      });

      test('Sets an property', () => {
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.an, 'app+analytics+test');
      });

      test('Sets cm property', () => {
        element.appId = 'Test aid';
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.aid, 'Test+aid');
      });

      test('Sets aiid property', () => {
        element.appInstallerId = 'Test id';
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.aiid, 'Test+id');
      });

      test('Sets custom metrics', () => {
        element._setCustomMetrics([{index: 2, value: 'x y'}]);
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.cm2, 'x+y');
      });

      test('Sets custom metrics', () => {
        element._setCustomDimensions([{index: 2, value: 'x y'}]);
        element._configureBaseParams();
        const p = element.baseParams;
        assert.equal(p.cd2, 'x+y');
      });
    });

    suite('_sendHandler()', () => {
      let element;

      setup(() => {
        element = fixture('DebugEndpoint');
        element.__testRunner = true;
      });

      function fire(detail) {
        const e = new CustomEvent('send-analytics', {
          bubbles: true,
          detail
        });
        document.body.dispatchEvent(e);
      }

      test('Does nothing when event type is unknwon', () => {
        fire({
          type: 'other'
        });
        // no error
      });

      test('Does nothing when disabled', () => {
        element.disabled = true;
        fire({
          type: 'other'
        });
        // no error
        element.disabled = false;
      });

      test('Calls sendScreen()', () => {
        const spy = sinon.spy(element, 'sendScreen');
        fire({
          type: 'screenview',
          name: 'Test'
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'Test');
      });

      test('Calls sendEvent()', () => {
        const spy = sinon.spy(element, 'sendEvent');
        fire({
          type: 'event',
          category: 'ec',
          action: 'ea',
          label: 'el',
          value: 'ev'
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'ec');
        assert.equal(spy.args[0][1], 'ea');
        assert.equal(spy.args[0][2], 'el');
        assert.equal(spy.args[0][3], 'ev');
      });

      test('Calls sendException()', () => {
        const spy = sinon.spy(element, 'sendException');
        fire({
          type: 'exception',
          description: 'ed',
          fatal: true
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'ed');
        assert.equal(spy.args[0][1], true);
      });

      test('Calls sendSocial()', () => {
        const spy = sinon.spy(element, 'sendSocial');
        fire({
          type: 'social',
          network: 'sn',
          action: 'sa',
          target: 'st'
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'sn');
        assert.equal(spy.args[0][1], 'sa');
        assert.equal(spy.args[0][2], 'st');
      });

      test('Calls sendTimings()', () => {
        const spy = sinon.spy(element, 'sendTimings');
        fire({
          type: 'timing',
          category: 'tc',
          variable: 'tvar',
          value: 'tv',
          label: 'tl'
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'tc');
        assert.equal(spy.args[0][1], 'tvar');
        assert.equal(spy.args[0][2], 'tv');
        assert.equal(spy.args[0][3], 'tl');
      });

      test('sendTimings() will not throw error', () => {
        fire({
          type: 'timing',
          variable: 'tvar',
          value: 'tv',
          label: 'tl'
        });
      });
    });
    </script>

  </body>
</html>
